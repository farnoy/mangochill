#[cfg(not(target_arch = "wasm32"))]
use capnp_rpc::{RpcSystem, rpc_twoparty_capnp::Side};
#[cfg(not(target_arch = "wasm32"))]
use chrono::{DateTime, Utc};
#[cfg(not(target_arch = "wasm32"))]
use mimalloc::MiMalloc;
#[cfg(not(target_arch = "wasm32"))]
use serde::{Deserialize, Serialize};
#[cfg(not(target_arch = "wasm32"))]
use std::path::PathBuf;
#[cfg(not(target_arch = "wasm32"))]
use tokio::net::UnixStream;
#[cfg(not(target_arch = "wasm32"))]
use tokio_util::compat::{TokioAsyncReadCompatExt, TokioAsyncWriteCompatExt};

#[cfg(not(target_arch = "wasm32"))]
pub mod mangochill_capnp {
    // Generated by capnpc; keep it out of our clippy/warnings budget.
    #![allow(clippy::all)]
    include!(concat!(env!("OUT_DIR"), "/mangochill_capnp.rs"));
}

#[cfg(not(target_arch = "wasm32"))]
pub mod bootstrap;
pub mod ewm;
#[cfg(not(target_arch = "wasm32"))]
pub mod fps_limiter;

#[cfg(not(target_arch = "wasm32"))]
#[global_allocator]
static GLOBAL: MiMalloc = MiMalloc;

#[cfg(not(target_arch = "wasm32"))]
#[derive(Serialize, Deserialize)]
pub struct LogRecord {
    pub collected_at: DateTime<Utc>,
    pub rpc_at: DateTime<Utc>,
    pub readings: Vec<DateTime<Utc>>,
}

#[cfg(not(target_arch = "wasm32"))]
pub fn socket_path(input: Option<PathBuf>) -> PathBuf {
    input.unwrap_or_else(|| PathBuf::from("/run/mangochill/server.sock"))
}

#[cfg(not(target_arch = "wasm32"))]
pub async fn connect_rpc(
    rpc_socket: &PathBuf,
) -> anyhow::Result<(RpcSystem<Side>, mangochill_capnp::mango_chill::Client)> {
    let stream = UnixStream::connect(&rpc_socket).await?;
    let (reader, writer) = stream.into_split();
    let reader = TokioAsyncReadCompatExt::compat(reader);
    let reader = futures::io::BufReader::new(reader);
    let writer = TokioAsyncWriteCompatExt::compat_write(writer);
    let writer = futures::io::BufWriter::new(writer);

    let network = capnp_rpc::twoparty::VatNetwork::new(
        reader,
        writer,
        capnp_rpc::rpc_twoparty_capnp::Side::Client,
        Default::default(),
    );

    let mut rpc_system = RpcSystem::new(Box::new(network), None);
    let client = rpc_system.bootstrap(Side::Server);
    Ok((rpc_system, client))
}

#[cfg(not(target_arch = "wasm32"))]
pub fn init_logging(filter: log::LevelFilter) {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("error"))
        .filter_level(filter)
        .init();
}

#[cfg(not(target_arch = "wasm32"))]
pub fn monotonic_us() -> i64 {
    use nix::time::{ClockId, clock_gettime};
    let ts = clock_gettime(ClockId::CLOCK_MONOTONIC).unwrap();
    ts.tv_sec() * 1_000_000 + ts.tv_nsec() / 1000
}

#[cfg(not(target_arch = "wasm32"))]
pub async fn termination_signal() {
    use tokio::signal::unix::{SignalKind, signal};
    let mut sigterm = signal(SignalKind::terminate()).unwrap();
    let mut sigint = signal(SignalKind::interrupt()).unwrap();
    let mut sigquit = signal(SignalKind::quit()).unwrap();
    tokio::select! {
        _ = sigterm.recv() => {}
        _ = sigint.recv() => {}
        _ = sigquit.recv() => {}
    }
}
